# Additional changes to Inox's fix-building-without-safebrowsing.patch

--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4135,11 +4135,13 @@ ChromeContentBrowserClient::CreateThrott
                    &throttles);
 #endif
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (base::FeatureList::IsEnabled(safe_browsing::kDelayedWarnings)) {
     throttles.push_back(
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
@@ -5439,26 +5441,7 @@ ChromeContentBrowserClient::GetSafeBrows
     const std::vector<std::string>& allowlist_domains) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
-  // Should not bypass safe browsing check if the check is for enterprise
-  // lookup.
-  if (!safe_browsing_enabled_for_profile && !should_check_on_sb_disabled)
-    return nullptr;
-
-  // |safe_browsing_service_| may be unavailable in tests.
-  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_ =
-        base::MakeRefCounted<safe_browsing::UrlCheckerDelegateImpl>(
-            safe_browsing_service_->database_manager(),
-            safe_browsing_service_->ui_manager());
-  }
-
-  // Update allowlist domains.
-  if (safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_->SetPolicyAllowlistDomains(
-        allowlist_domains);
-  }
-
-  return safe_browsing_url_checker_delegate_;
+  return nullptr;
 }
 
 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -5479,11 +5462,6 @@ ChromeContentBrowserClient::GetUrlLookup
         GetForProfile(profile);
   }
 #endif
-
-  if (is_consumer_lookup_enabled) {
-    return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
-        profile);
-  }
   return nullptr;
 }
 
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -129,7 +129,6 @@ using content::DownloadManager;
 using download::DownloadItem;
 using download::DownloadPathReservationTracker;
 using download::PathValidationResult;
-using safe_browsing::DownloadFileType;
 using safe_browsing::DownloadProtectionService;
 using ConnectionType = net::NetworkChangeNotifier::ConnectionType;
 
@@ -1426,8 +1425,6 @@ void ChromeDownloadManagerDelegate::OnDo
     if (item->GetOriginalMimeType() == "application/x-x509-user-cert")
       DownloadItemModel(item).SetShouldPreferOpeningInBrowser(true);
 #endif
-
-    DownloadItemModel(item).SetDangerLevel(target_info->danger_level);
   }
   if (ShouldBlockFile(target_info->danger_type, item)) {
     MaybeReportDangerousDownloadBlocked(
--- a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
+++ b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
@@ -37,13 +37,11 @@
 #include "chrome/browser/safe_browsing/cloud_content_scanning/binary_upload_service_factory.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_utils.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/file_analysis_request.h"
-#include "chrome/browser/safe_browsing/download_protection/check_client_download_request.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
 #include "components/policy/core/browser/url_util.h"
 #include "components/policy/core/common/chrome_schema.h"
 #include "components/prefs/pref_service.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/safe_browsing/core/features.h"
 #include "components/url_matcher/url_matcher.h"
 #include "content/public/browser/web_contents.h"
--- a/chrome/browser/enterprise/connectors/connectors_service.cc
+++ b/chrome/browser/enterprise/connectors/connectors_service.cc
@@ -365,34 +365,12 @@ std::vector<std::string> ConnectorsServi
 
 absl::optional<std::string> ConnectorsService::GetDMTokenForRealTimeUrlCheck()
     const {
-  if (!ConnectorsEnabled())
-    return absl::nullopt;
-
-  if (Profile::FromBrowserContext(context_)->GetPrefs()->GetInteger(
-          prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckMode) ==
-      safe_browsing::REAL_TIME_CHECK_DISABLED) {
-    return absl::nullopt;
-  }
-
-  absl::optional<DmToken> dm_token =
-      GetDmToken(prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckScope);
-
-  if (dm_token.has_value())
-    return dm_token.value().value;
   return absl::nullopt;
 }
 
 safe_browsing::EnterpriseRealTimeUrlCheckMode
 ConnectorsService::GetAppliedRealTimeUrlCheck() const {
-  if (!ConnectorsEnabled() ||
-      !GetDmToken(prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckScope)
-           .has_value()) {
-    return safe_browsing::REAL_TIME_CHECK_DISABLED;
-  }
-
-  return static_cast<safe_browsing::EnterpriseRealTimeUrlCheckMode>(
-      Profile::FromBrowserContext(context_)->GetPrefs()->GetInteger(
-          prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckMode));
+  return safe_browsing::REAL_TIME_CHECK_DISABLED;
 }
 
 ConnectorsManager* ConnectorsService::ConnectorsManagerForTesting() {
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -307,6 +307,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -336,6 +337,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialShown(
@@ -363,6 +365,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyInterstitialEvent) == 0) {
@@ -385,6 +388,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialProceeded(
@@ -412,6 +416,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyInterstitialEvent) == 0) {
@@ -430,6 +435,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorResult(
@@ -443,6 +449,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   if (result.tag() == "malware") {
     DCHECK_EQ(1, result.triggered_rules().size());
     OnDangerousDeepScanningResult(
@@ -454,6 +461,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     OnSensitiveDataEvent(url, file_name, download_digest_sha256, mime_type,
                          trigger, scan_id, result, content_size, event_result);
   }
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
@@ -469,6 +477,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& malware_category,
     const std::string& evidence_locker_filepath,
     const std::string& scan_id) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -505,6 +514,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
@@ -517,6 +527,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeySensitiveDataEvent) == 0) {
@@ -548,6 +559,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
@@ -560,6 +572,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     safe_browsing::DeepScanAccessPoint access_point,
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeySensitiveDataEvent) == 0) {
@@ -591,6 +604,7 @@ void SafeBrowsingPrivateEventRouter::OnA
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
@@ -603,6 +617,7 @@ void SafeBrowsingPrivateEventRouter::OnU
     const std::string& reason,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyUnscannedFileEvent) == 0) {
@@ -628,6 +643,7 @@ void SafeBrowsingPrivateEventRouter::OnU
 
   ReportRealtimeEvent(kKeyUnscannedFileEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDownloadEvent(
@@ -653,6 +669,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& scan_id,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -682,6 +699,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDownloadWarningBypassed(
@@ -705,6 +723,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& mime_type,
     const std::string& scan_id,
     const int64_t content_size) {
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -734,6 +753,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 // static
@@ -1006,7 +1026,11 @@ void SafeBrowsingPrivateEventRouter::Rep
 }
 
 std::string SafeBrowsingPrivateEventRouter::GetProfileUserName() const {
+#if defined(FULL_SAFE_BROWSING)
   return safe_browsing::GetProfileEmail(identity_manager_);
+#else
+  return "";
+#endif
 }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -35,7 +35,6 @@
 #include "chrome/browser/file_system_access/file_system_access_permission_request_manager.h"
 #include "chrome/browser/installable/installable_utils.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
 #include "chrome/browser/ui/file_system_access_dialogs.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/content_settings/core/browser/host_content_settings_map.h"
@@ -310,80 +309,6 @@ BindResultCallbackToCurrentSequence(
       base::SequencedTaskRunnerHandle::Get(), std::move(callback));
 }
 
-void DoSafeBrowsingCheckOnUIThread(
-    content::GlobalFrameRoutingId frame_id,
-    std::unique_ptr<content::FileSystemAccessWriteItem> item,
-    safe_browsing::CheckDownloadCallback callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  // Download Protection Service is not supported on Android.
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (!sb_service || !sb_service->download_protection_service() ||
-      !sb_service->download_protection_service()->enabled()) {
-    std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-    return;
-  }
-
-  if (!item->browser_context) {
-    content::RenderProcessHost* rph =
-        content::RenderProcessHost::FromID(frame_id.child_id);
-    if (!rph) {
-      std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-      return;
-    }
-    item->browser_context = rph->GetBrowserContext();
-  }
-
-  if (!item->web_contents) {
-    content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(frame_id);
-    if (rfh)
-      item->web_contents = content::WebContents::FromRenderFrameHost(rfh);
-  }
-
-  sb_service->download_protection_service()->CheckFileSystemAccessWrite(
-      std::move(item), std::move(callback));
-#endif
-}
-
-ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult
-InterpretSafeBrowsingResult(safe_browsing::DownloadCheckResult result) {
-  using Result = safe_browsing::DownloadCheckResult;
-  switch (result) {
-    // Only allow downloads that are marked as SAFE or UNKNOWN by SafeBrowsing.
-    // All other types are going to be blocked. UNKNOWN could be the result of a
-    // failed safe browsing ping.
-    case Result::UNKNOWN:
-    case Result::SAFE:
-    case Result::ALLOWLISTED_BY_POLICY:
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kAllow;
-
-    case Result::DANGEROUS:
-    case Result::UNCOMMON:
-    case Result::DANGEROUS_HOST:
-    case Result::POTENTIALLY_UNWANTED:
-    case Result::BLOCKED_PASSWORD_PROTECTED:
-    case Result::BLOCKED_TOO_LARGE:
-    case Result::BLOCKED_UNSUPPORTED_FILE_TYPE:
-    case Result::DANGEROUS_ACCOUNT_COMPROMISE:
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kBlock;
-
-    // This shouldn't be returned for File System Access write checks.
-    case Result::ASYNC_SCANNING:
-    case Result::SENSITIVE_CONTENT_WARNING:
-    case Result::SENSITIVE_CONTENT_BLOCK:
-    case Result::DEEP_SCANNED_SAFE:
-    case Result::PROMPT_FOR_SCANNING:
-      NOTREACHED();
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kAllow;
-  }
-  NOTREACHED();
-  return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::kBlock;
-}
-
 std::string GenerateLastPickedDirectoryKey(const std::string& id) {
   return id.empty() ? kDefaultLastPickedDirectoryKey
                     : base::StrCat({kCustomLastPickedDirectoryKey, "-", id});
@@ -1114,28 +1039,6 @@ void ChromeFileSystemAccessPermissionCon
                      std::move(callback)));
 }
 
-void ChromeFileSystemAccessPermissionContext::PerformAfterWriteChecks(
-    std::unique_ptr<content::FileSystemAccessWriteItem> item,
-    content::GlobalFrameRoutingId frame_id,
-    base::OnceCallback<void(AfterWriteCheckResult)> callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  content::GetUIThreadTaskRunner({})->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          &DoSafeBrowsingCheckOnUIThread, frame_id, std::move(item),
-          base::BindOnce(
-              [](scoped_refptr<base::TaskRunner> task_runner,
-                 base::OnceCallback<void(AfterWriteCheckResult result)>
-                     callback,
-                 safe_browsing::DownloadCheckResult result) {
-                task_runner->PostTask(
-                    FROM_HERE,
-                    base::BindOnce(std::move(callback),
-                                   InterpretSafeBrowsingResult(result)));
-              },
-              base::SequencedTaskRunnerHandle::Get(), std::move(callback))));
-}
-
 void ChromeFileSystemAccessPermissionContext::
     DidConfirmSensitiveDirectoryAccess(
         const url::Origin& origin,
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
@@ -85,10 +85,6 @@ class ChromeFileSystemAccessPermissionCo
       HandleType handle_type,
       content::GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) override;
-  void PerformAfterWriteChecks(
-      std::unique_ptr<content::FileSystemAccessWriteItem> item,
-      content::GlobalFrameRoutingId frame_id,
-      base::OnceCallback<void(AfterWriteCheckResult)> callback) override;
   bool CanObtainReadPermission(const url::Origin& origin) override;
   bool CanObtainWritePermission(const url::Origin& origin) override;
 
--- a/chrome/browser/media/webrtc/display_media_access_handler.cc
+++ b/chrome/browser/media/webrtc/display_media_access_handler.cc
@@ -108,6 +108,7 @@ void DisplayMediaAccessHandler::HandleRe
     return;
   }
 
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -122,6 +123,7 @@ void DisplayMediaAccessHandler::HandleRe
     observer->OnDesktopCaptureRequest();
     return;
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 #if defined(OS_MAC)
   // Do not allow picker UI to be shown on a page that isn't in the foreground
--- a/chrome/browser/password_manager/chrome_password_manager_client.cc
+++ b/chrome/browser/password_manager/chrome_password_manager_client.cc
@@ -32,7 +32,6 @@
 #include "chrome/browser/password_manager/field_info_manager_factory.h"
 #include "chrome/browser/password_manager/password_store_factory.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/chrome_password_protection_service.h"
 #include "chrome/browser/safe_browsing/user_interaction_observer.h"
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "chrome/browser/sync/sync_service_factory.h"
@@ -109,11 +108,11 @@
 #if BUILDFLAG(FULL_SAFE_BROWSING)
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager.h"
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager_factory.h"
+#endif
 #include "third_party/blink/public/mojom/clipboard/clipboard.mojom.h"
 #include "ui/base/clipboard/clipboard.h"
 #include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
 #include "ui/events/keycodes/keyboard_codes.h"
-#endif
 
 #if defined(OS_ANDROID)
 #include "base/feature_list.h"
@@ -806,6 +805,7 @@ autofill::LanguageCode ChromePasswordMan
   return autofill::LanguageCode();
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 safe_browsing::PasswordProtectionService*
 ChromePasswordManagerClient::GetPasswordProtectionService() const {
   return safe_browsing::ChromePasswordProtectionService::
@@ -816,13 +816,6 @@ ChromePasswordManagerClient::GetPassword
 void ChromePasswordManagerClient::CheckSafeBrowsingReputation(
     const GURL& form_action,
     const GURL& frame_url) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeStartPasswordFieldOnFocusRequest(
-        web_contents(), web_contents()->GetLastCommittedURL(), form_action,
-        frame_url, pps->GetAccountInfo().hosted_domain);
-  }
 }
 #endif  // defined(ON_FOCUS_PING_ENABLED)
 
@@ -832,22 +825,10 @@ void ChromePasswordManagerClient::CheckP
     const std::vector<password_manager::MatchingReusedCredential>&
         matching_reused_credentials,
     bool password_field_exists) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (!pps)
-    return;
-
-  pps->MaybeStartProtectedPasswordEntryRequest(
-      web_contents(), web_contents()->GetLastCommittedURL(), username,
-      password_type, matching_reused_credentials, password_field_exists);
 }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 void ChromePasswordManagerClient::LogPasswordReuseDetectedEvent() {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeLogPasswordReuseDetectedEvent(web_contents());
-  }
 }
 
 ukm::SourceId ChromePasswordManagerClient::GetUkmSourceId() {
@@ -1322,9 +1303,11 @@ void ChromePasswordManagerClient::OnPast
   }
 
   was_on_paste_called_ = true;
+#if defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
   password_reuse_detection_manager_.OnPaste(std::move(text));
+#endif // defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
 }
-#endif
+#endif // !defined(OS_ANDROID)
 
 void ChromePasswordManagerClient::RenderFrameCreated(
     content::RenderFrameHost* render_frame_host) {
@@ -1359,7 +1342,9 @@ void ChromePasswordManagerClient::OnInpu
   if (key_event.windows_key_code == (ui::VKEY_V & 0x1f)) {
     OnPaste();
   } else {
+#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
     password_reuse_detection_manager_.OnKeyPressedCommitted(key_event.text);
+#endif  // defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
   }
 #endif  // defined(OS_ANDROID)
 }
@@ -1398,6 +1383,7 @@ bool ChromePasswordManagerClient::IsPass
     is_enabled = false;
   }
 
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Disable password
@@ -1408,6 +1394,7 @@ bool ChromePasswordManagerClient::IsPass
     observer->OnPasswordSaveOrAutofillDenied();
     is_enabled = false;
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   if (log_manager_->IsLoggingActive()) {
     password_manager::BrowserSavePasswordProgressLogger logger(
--- a/chrome/browser/password_manager/chrome_password_manager_client.h
+++ b/chrome/browser/password_manager/chrome_password_manager_client.h
@@ -191,13 +191,14 @@ class ChromePasswordManagerClient
   void AnnotateNavigationEntry(bool has_password_field) override;
   autofill::LanguageCode GetPageLanguage() const override;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::PasswordProtectionService* GetPasswordProtectionService()
       const override;
 
 #if defined(ON_FOCUS_PING_ENABLED)
   void CheckSafeBrowsingReputation(const GURL& form_action,
                                    const GURL& frame_url) override;
-#endif
+#endif // defined(ON_FOCUS_PING_ENABLED)
 
   void CheckProtectedPasswordEntry(
       password_manager::metrics_util::PasswordType reused_password_type,
@@ -205,6 +206,7 @@ class ChromePasswordManagerClient
       const std::vector<password_manager::MatchingReusedCredential>&
           matching_reused_credentials,
       bool password_field_exists) override;
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   void LogPasswordReuseDetectedEvent() override;
 
--- a/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
+++ b/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
@@ -16,7 +16,6 @@
 #include "components/permissions/permission_uma_util.h"
 #include "components/permissions/permissions_client.h"
 #include "components/prefs/pref_service.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/safe_browsing/core/db/database_manager.h"
 
 namespace {
@@ -136,6 +135,7 @@ void AbusiveOriginPermissionRevocationRe
   DCHECK(profile_);
   DCHECK(callback_);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!AbusiveOriginNotificationsPermissionRevocationConfig::IsEnabled() ||
       !safe_browsing::IsSafeBrowsingEnabled(*profile_->GetPrefs()) ||
       IsOriginExemptedFromFutureRevocations(profile_, origin_)) {
@@ -155,10 +155,14 @@ void AbusiveOriginPermissionRevocationRe
       base::BindOnce(
           &AbusiveOriginPermissionRevocationRequest::OnSiteReputationReady,
           weak_factory_.GetWeakPtr()));
+#else
+  NotifyCallback(Outcome::PERMISSION_NOT_REVOKED);
+#endif
 }
 
 void AbusiveOriginPermissionRevocationRequest::OnSiteReputationReady(
     const CrowdDenyPreloadData::SiteReputation* site_reputation) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (crowd_deny_request_start_time_.has_value()) {
     crowd_deny_request_duration_ =
         base::TimeTicks::Now() - crowd_deny_request_start_time_.value();
@@ -181,6 +185,7 @@ void AbusiveOriginPermissionRevocationRe
       return;
     }
   }
+#endif
   NotifyCallback(Outcome::PERMISSION_NOT_REVOKED);
 }
 
--- a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
+++ b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
@@ -17,11 +17,9 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_config.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_state.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/common/chrome_features.h"
 #include "components/permissions/permission_request.h"
 #include "components/permissions/request_type.h"
-#include "components/safe_browsing/core/db/database_manager.h"
 
 namespace {
 
@@ -151,9 +149,6 @@ void ContextualNotificationPermissionUiS
 }
 
 void ContextualNotificationPermissionUiSelector::Cancel() {
-  // The computation either finishes synchronously above, or is waiting on the
-  // Safe Browsing check.
-  safe_browsing_request_.reset();
 }
 
 bool ContextualNotificationPermissionUiSelector::IsPermissionRequestSupported(
@@ -179,24 +174,14 @@ void ContextualNotificationPermissionUiS
   absl::optional<Decision> decision =
       GetDecisionBasedOnSiteReputation(reputation);
 
-  // If the PreloadData suggests this is an unacceptable site, ping Safe
-  // Browsing to verify; but do not ping if it is not warranted.
+  // If the PreloadData suggests this is an unacceptable site, assume it is
+  // correct, since we can't access safe browsing.
   if (!decision || (!decision->quiet_ui_reason && !decision->warning_reason)) {
     Notify(Decision::UseNormalUiAndShowNoWarning());
-    return;
+  } else {
+    // decision has a value, unwrap with .value()
+    Notify(decision.value());
   }
-
-  DCHECK(!safe_browsing_request_);
-  DCHECK(g_browser_process->safe_browsing_service());
-
-  // It is fine to use base::Unretained() here, as |safe_browsing_request_|
-  // guarantees not to fire the callback after its destruction.
-  safe_browsing_request_.emplace(
-      g_browser_process->safe_browsing_service()->database_manager(),
-      base::DefaultClock::GetInstance(), origin,
-      base::BindOnce(&ContextualNotificationPermissionUiSelector::
-                         OnSafeBrowsingVerdictReceived,
-                     base::Unretained(this), *decision));
 }
 
 void ContextualNotificationPermissionUiSelector::OnSafeBrowsingVerdictReceived(
--- a/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
+++ b/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
@@ -22,7 +22,6 @@
 #include "components/permissions/prediction_service/prediction_service.h"
 #include "components/permissions/prediction_service/prediction_service_messages.pb.h"
 #include "components/prefs/pref_service.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 
 namespace {
 
@@ -205,8 +204,7 @@ bool PredictionBasedPermissionUiSelector
     permissions::RequestType request_type) {
   // We need to also check `kQuietNotificationPrompts` here since there is no
   // generic safeguard anywhere else in the stack.
-  if (!base::FeatureList::IsEnabled(features::kQuietNotificationPrompts) ||
-      !safe_browsing::IsSafeBrowsingEnabled(*(profile_->GetPrefs()))) {
+  if (!base::FeatureList::IsEnabled(features::kQuietNotificationPrompts)) {
     return false;
   }
   double hold_back_chance = 0.0;
--- a/chrome/browser/reputation/reputation_service.cc
+++ b/chrome/browser/reputation/reputation_service.cc
@@ -119,9 +119,7 @@ void ReputationService::GetReputationSta
                                             ReputationCheckCallback callback) {
   DCHECK(url.SchemeIsHTTPOrHTTPS());
 
-  bool has_delayed_warning =
-      !!safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
-          web_contents);
+  bool has_delayed_warning = false;
 
   LookalikeUrlService* service = LookalikeUrlService::Get(profile_);
   if (service->EngagedSitesNeedUpdating()) {
--- a/chrome/browser/safe_browsing/url_lookup_service_factory.cc
+++ b/chrome/browser/safe_browsing/url_lookup_service_factory.cc
@@ -57,28 +57,7 @@ RealTimeUrlLookupServiceFactory::RealTim
 
 KeyedService* RealTimeUrlLookupServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
-  if (!g_browser_process->safe_browsing_service()) {
-    return nullptr;
-  }
-  Profile* profile = Profile::FromBrowserContext(context);
-  auto url_loader_factory =
-      std::make_unique<network::CrossThreadPendingSharedURLLoaderFactory>(
-          g_browser_process->safe_browsing_service()->GetURLLoaderFactory(
-              profile));
-  return new RealTimeUrlLookupService(
-      network::SharedURLLoaderFactory::Create(std::move(url_loader_factory)),
-      VerdictCacheManagerFactory::GetForProfile(profile),
-      base::BindRepeating(&safe_browsing::GetUserPopulation, profile),
-      profile->GetPrefs(),
-      std::make_unique<SafeBrowsingPrimaryAccountTokenFetcher>(
-          IdentityManagerFactory::GetForProfile(profile)),
-      base::BindRepeating(&safe_browsing::SyncUtils::
-                              AreSigninAndSyncSetUpForSafeBrowsingTokenFetches,
-                          SyncServiceFactory::GetForProfile(profile),
-                          IdentityManagerFactory::GetForProfile(profile)),
-      profile->IsOffTheRecord(), g_browser_process->variations_service(),
-      SafeBrowsingNavigationObserverManagerFactory::GetForBrowserContext(
-          profile));
+  return nullptr;
 }
 
 }  // namespace safe_browsing
--- a/chrome/browser/ssl/sct_reporting_service_factory.cc
+++ b/chrome/browser/ssl/sct_reporting_service_factory.cc
@@ -32,15 +32,7 @@ SCTReportingServiceFactory::~SCTReportin
 
 KeyedService* SCTReportingServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* profile) const {
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-  // In unit tests the safe browsing service can be null, if this happens,
-  // return null instead of crashing.
-  if (!safe_browsing_service)
-    return nullptr;
-
-  return new SCTReportingService(safe_browsing_service,
-                                 static_cast<Profile*>(profile));
+  return nullptr;
 }
 
 content::BrowserContext* SCTReportingServiceFactory::GetBrowserContextToUse(
--- a/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
+++ b/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
@@ -36,6 +36,7 @@ JavaScriptTabModalDialogManagerDelegateD
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::WillRunDialog() {
   BrowserList::AddObserver(this);
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -46,6 +47,7 @@ void JavaScriptTabModalDialogManagerDele
   if (observer) {
     observer->OnJavaScriptDialog();
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 }
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::DidCloseDialog() {
--- a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
+++ b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
@@ -79,37 +79,8 @@ void HandleOnPerformDrop(
     content::WebContents* web_contents,
     const content::DropData& drop_data,
     content::WebContentsViewDelegate::DropCompletionCallback callback) {
-  enterprise_connectors::ContentAnalysisDelegate::Data data;
-  Profile* profile =
-      Profile::FromBrowserContext(web_contents->GetBrowserContext());
-  auto connector =
-      drop_data.filenames.empty()
-          ? enterprise_connectors::AnalysisConnector::BULK_DATA_ENTRY
-          : enterprise_connectors::AnalysisConnector::FILE_ATTACHED;
-  if (!enterprise_connectors::ContentAnalysisDelegate::IsEnabled(
-          profile, web_contents->GetLastCommittedURL(), &data, connector)) {
-    std::move(callback).Run(
-        content::WebContentsViewDelegate::DropCompletionResult::kContinue);
-    return;
-  }
-
-  // Collect the data that needs to be scanned.
-  if (!drop_data.url_title.empty())
-    data.text.push_back(drop_data.url_title);
-  if (drop_data.text)
-    data.text.push_back(*drop_data.text);
-  if (drop_data.html)
-    data.text.push_back(*drop_data.html);
-  if (!drop_data.file_contents.empty())
-    data.text.push_back(base::UTF8ToUTF16(drop_data.file_contents));
-
-  if (drop_data.filenames.empty()) {
-    ScanData(web_contents, std::move(callback), std::move(data));
-  } else {
-    base::ThreadPool::PostTaskAndReplyWithResult(
-        FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
-        base::BindOnce(&GetPathsToScan, web_contents, std::move(drop_data),
-                       std::move(data)),
-        base::BindOnce(&ScanData, web_contents, std::move(callback)));
-  }
+  // In the original code, this ran safe_browsing::DeepScanningDialogDelegate
+  // Instead, run the code under "if (!safe_browsing::DeepScanningDialogDelegate::IsEnabled(...)) ..."
+  std::move(callback).Run(
+      content::WebContentsViewDelegate::DropCompletionResult::kContinue);
 }
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -790,9 +790,7 @@ void DownloadItemView::UpdateLabels() {
   deep_scanning_label_->SetVisible(mode_ ==
                                    download::DownloadItemMode::kDeepScanning);
   if (deep_scanning_label_->GetVisible()) {
-    const int id = (model_->download() &&
-                    safe_browsing::DeepScanningRequest::ShouldUploadBinary(
-                        model_->download()))
+    const int id = model_->download()
                        ? IDS_PROMPT_DEEP_SCANNING_DOWNLOAD
                        : IDS_PROMPT_DEEP_SCANNING_APP_DOWNLOAD;
     const std::u16string filename = ElidedFilename(*deep_scanning_label_);
@@ -816,11 +814,15 @@ void DownloadItemView::UpdateButtons() {
   }
 
   const bool allow_open_during_deep_scan =
+#if BUILDFLAG(FULL_SAFE_BROWSING)
       (mode_ == download::DownloadItemMode::kDeepScanning) &&
       !enterprise_connectors::ConnectorsServiceFactory::GetForBrowserContext(
            model_->profile())
            ->DelayUntilVerdict(
                enterprise_connectors::AnalysisConnector::FILE_DOWNLOADED);
+#else
+      false;
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
   open_button_->SetEnabled((mode_ == download::DownloadItemMode::kNormal) ||
                            prompt_to_scan || allow_open_during_deep_scan);
 
@@ -1262,7 +1264,9 @@ void DownloadItemView::ShowContextMenuIm
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   model_->CompleteSafeBrowsingScan();
+#endif
   model_->SetOpenWhenComplete(true);
 }
 
--- a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
+++ b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
@@ -179,10 +179,7 @@ PasswordReuseModalWarningDialog::Passwor
         placeholder_offsets);
   } else {
     views::Label* message_body_label = CreateMessageBodyLabel(
-        service_
-            ? service_->GetWarningDetailText(password_type,
-                                             &placeholder_offsets)
-            : l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
+        l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
     CreateGaiaPasswordReuseModalWarningDialog(message_body_label);
   }
   modal_construction_start_time_ = base::TimeTicks::Now();
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -78,8 +78,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/reading_list/features/reading_list_switches.h"
 #include "components/safe_browsing/buildflags.h"
-#include "components/safe_browsing/content/web_ui/safe_browsing_ui.h"
-#include "components/safe_browsing/core/web_ui/constants.h"
 #include "components/security_interstitials/content/connection_help_ui.h"
 #include "components/security_interstitials/content/known_interception_disclosure_ui.h"
 #include "components/security_interstitials/content/urls.h"
@@ -624,8 +622,6 @@ WebUIFactoryFunction GetWebUIFactoryFunc
     return &NewWebUI<PredictorsUI>;
   if (url.host_piece() == chrome::kChromeUIQuotaInternalsHost)
     return &NewWebUI<QuotaInternalsUI>;
-  if (url.host_piece() == safe_browsing::kChromeUISafeBrowsingHost)
-    return &NewWebUI<safe_browsing::SafeBrowsingUI>;
   if (url.host_piece() == chrome::kChromeUISignInInternalsHost)
     return &NewWebUI<SignInInternalsUI>;
   if (url.host_piece() == chrome::kChromeUISuggestionsHost)
--- a/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
+++ b/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
@@ -360,7 +360,6 @@ void DownloadsDOMHandler::OpenDuringScan
   if (download) {
     DownloadItemModel model(download);
     model.SetOpenWhenComplete(true);
-    model.CompleteSafeBrowsingScan();
   }
 }
 
--- a/chrome/browser/ui/webui/management/management_ui_handler.cc
+++ b/chrome/browser/ui/webui/management/management_ui_handler.cc
@@ -813,12 +813,6 @@ base::Value ManagementUIHandler::GetThre
                                   &info);
   }
 
-  if (connectors_service->GetAppliedRealTimeUrlCheck() !=
-      safe_browsing::REAL_TIME_CHECK_DISABLED) {
-    AddThreatProtectionPermission(kManagementOnPageVisitedEvent,
-                                  kManagementOnPageVisitedVisibleData, &info);
-  }
-
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   std::string enterprise_manager = GetDeviceManager();
   if (enterprise_manager.empty())
--- a/components/password_manager/content/browser/content_password_manager_driver.cc
+++ b/components/password_manager/content/browser/content_password_manager_driver.cc
@@ -318,7 +318,7 @@ void ContentPasswordManagerDriver::Check
   if (client_->GetMetricsRecorder()) {
     client_->GetMetricsRecorder()->RecordUserFocusedPasswordField();
   }
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   client_->CheckSafeBrowsingReputation(form_action, frame_url);
 #endif
 }
--- a/components/password_manager/core/browser/password_manager_client.h
+++ b/components/password_manager/core/browser/password_manager_client.h
@@ -331,11 +331,14 @@ class PasswordManagerClient {
   // Returns the current best guess as to the page's display language.
   virtual autofill::LanguageCode GetPageLanguage() const;
 
+#if (defined(ON_FOCUS_PING_ENABLED) || defined(PASSWORD_REUSE_DETECTION_ENABLED)) && \
+    BUILDFLAG(FULL_SAFE_BROWSING)
   // Return the PasswordProtectionService associated with this instance.
   virtual safe_browsing::PasswordProtectionService*
   GetPasswordProtectionService() const = 0;
+#endif
 
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   // Checks the safe browsing reputation of the webpage when the
   // user focuses on a username/password field. This is used for reporting
   // only, and won't trigger a warning.
@@ -343,6 +346,7 @@ class PasswordManagerClient {
                                            const GURL& frame_url) = 0;
 #endif
 
+#if defined(PASSWORD_REUSE_DETECTION_ENABLED)
   // Checks the safe browsing reputation of the webpage where password reuse
   // happens. This is called by the PasswordReuseDetectionManager when a
   // protected password is typed on the wrong domain. This may trigger a
@@ -355,6 +359,7 @@ class PasswordManagerClient {
       const std::string& username,
       const std::vector<MatchingReusedCredential>& matching_reused_credentials,
       bool password_field_exists) = 0;
+#endif
 
   // Records a Chrome Sync event that GAIA password reuse was detected.
   virtual void LogPasswordReuseDetectedEvent() = 0;
--- a/components/password_manager/core/browser/password_reuse_detection_manager.cc
+++ b/components/password_manager/core/browser/password_reuse_detection_manager.cc
@@ -170,10 +170,12 @@ void PasswordReuseDetectionManager::OnRe
                              ? reused_protected_password_hash->username
                              : "";
 
+#if defined(PASSWORD_REUSE_DETECTION_ENABLED)
   client_->CheckProtectedPasswordEntry(
       reused_password_type, username,
       std::move(all_matching_reused_credentials_).extract(),
       password_field_detected);
+#endif
 
   all_matching_reused_credentials_.clear();
 }
--- a/components/safe_browsing/content/common/safe_browsing.mojom
+++ b/components/safe_browsing/content/common/safe_browsing.mojom
@@ -120,7 +120,6 @@ enum PhishingDetectorResult {
   INVALID_SCORE = 4,
 };
 
-[EnableIf=full_safe_browsing]
 // Interface for setting the CSD model and to start phishing classification.
 interface PhishingDetector {
   // A classification model for client-side phishing detection.
--- a/components/safe_browsing/core/file_type_policies.cc
+++ b/components/safe_browsing/core/file_type_policies.cc
@@ -21,7 +21,9 @@ struct FileTypePoliciesSingletonTrait
     : public base::DefaultSingletonTraits<FileTypePolicies> {
   static FileTypePolicies* New() {
     FileTypePolicies* instance = new FileTypePolicies();
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     instance->PopulateFromResourceBundle();
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
     return instance;
   }
 };
@@ -48,10 +50,12 @@ FileTypePolicies::~FileTypePolicies() {
   AutoLock lock(lock_);  // DCHECK fail if the lock is held.
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 std::string FileTypePolicies::ReadResourceBundle() {
   ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
   return bundle.LoadDataResourceString(IDR_DOWNLOAD_FILE_TYPES_PB);
 }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 void FileTypePolicies::RecordUpdateMetrics(UpdateResult result,
                                            const std::string& src_name) {
@@ -67,12 +71,14 @@ void FileTypePolicies::RecordUpdateMetri
   }
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void FileTypePolicies::PopulateFromResourceBundle() {
   AutoLock lock(lock_);
   std::string binary_pb = ReadResourceBundle();
   UpdateResult result = PopulateFromBinaryPb(binary_pb);
   RecordUpdateMetrics(result, "ResourceBundle");
 }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 void FileTypePolicies::PopulateFromDynamicUpdate(const std::string& binary_pb) {
   AutoLock lock(lock_);
--- a/components/safe_browsing/core/file_type_policies.h
+++ b/components/safe_browsing/core/file_type_policies.h
@@ -11,6 +11,7 @@
 #include "base/files/file_path.h"
 #include "base/gtest_prod_util.h"
 #include "base/synchronization/lock.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/safe_browsing/core/proto/download_file_types.pb.h"
 
 namespace safe_browsing {
@@ -105,8 +106,10 @@ class FileTypePolicies {
   // only if it passes integrity checks.
   virtual UpdateResult PopulateFromBinaryPb(const std::string& binary_pb);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Fetch the blob from the main resource bundle.
   virtual std::string ReadResourceBundle();
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   // Record the result of an update attempt.
   virtual void RecordUpdateMetrics(UpdateResult result,
@@ -124,10 +127,12 @@ class FileTypePolicies {
   void SwapConfig(std::unique_ptr<DownloadFileTypeConfig>& new_config);
   void SwapConfigLocked(std::unique_ptr<DownloadFileTypeConfig>& new_config);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Read data from the main ResourceBundle. This updates the internal list
   // only if the data passes integrity checks. This is normally called once
   // after construction.
   void PopulateFromResourceBundle();
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   // The latest config we've committed. Starts out null.
   // Protected by lock_.
--- a/content/browser/file_system_access/file_system_access_file_writer_impl.cc
+++ b/content/browser/file_system_access/file_system_access_file_writer_impl.cc
@@ -339,15 +339,8 @@ void FileSystemAccessFileWriterImpl::Clo
 
   close_callback_ = std::move(callback);
 
-  if (!RequireSecurityChecks() || !manager()->permission_context()) {
-    DidAfterWriteCheck(
-        FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
-    return;
-  }
-
-  ComputeHashForSwapFile(
-      base::BindOnce(&FileSystemAccessFileWriterImpl::DoAfterWriteCheck,
-                     weak_factory_.GetWeakPtr()));
+  DidAfterWriteCheck(
+      FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
 }
 
 void FileSystemAccessFileWriterImpl::AbortImpl(AbortCallback callback) {
@@ -367,35 +360,6 @@ void FileSystemAccessFileWriterImpl::Abo
   manager()->RemoveFileWriter(this);
 }
 
-// static
-void FileSystemAccessFileWriterImpl::DoAfterWriteCheck(
-    base::File::Error hash_result,
-    const std::string& hash,
-    int64_t size) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
-  if (hash_result != base::File::FILE_OK) {
-    // Calculating the hash failed, the destructor will try to delete the swap
-    // file, so call the callback to report the error and delete `this`.
-    CallCloseCallbackAndDeleteThis(file_system_access_error::FromStatus(
-        FileSystemAccessStatus::kOperationAborted,
-        "Failed to perform Safe Browsing check."));
-    return;
-  }
-
-  auto item = std::make_unique<FileSystemAccessWriteItem>();
-  item->target_file_path = url().path();
-  item->full_path = swap_url().path();
-  item->sha256_hash = hash;
-  item->size = size;
-  item->frame_url = context().url;
-  item->has_user_gesture = has_transient_user_activation_;
-  manager()->permission_context()->PerformAfterWriteChecks(
-      std::move(item), context().frame_id,
-      base::BindOnce(&FileSystemAccessFileWriterImpl::DidAfterWriteCheck,
-                     weak_factory_.GetWeakPtr()));
-}
-
 void FileSystemAccessFileWriterImpl::DidAfterWriteCheck(
     FileSystemAccessPermissionContext::AfterWriteCheckResult result) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
--- a/content/browser/file_system_access/file_system_access_file_writer_impl.h
+++ b/content/browser/file_system_access/file_system_access_file_writer_impl.h
@@ -103,9 +103,6 @@ class CONTENT_EXPORT FileSystemAccessFil
   void TruncateImpl(uint64_t length, TruncateCallback callback);
   void CloseImpl(CloseCallback callback);
   void AbortImpl(AbortCallback callback);
-  void DoAfterWriteCheck(base::File::Error hash_result,
-                         const std::string& hash,
-                         int64_t size);
   void DidAfterWriteCheck(
       FileSystemAccessPermissionContext::AfterWriteCheckResult result);
   void DidSwapFileSkipQuarantine(base::File::Error result);
--- a/content/public/browser/file_system_access_permission_context.h
+++ b/content/public/browser/file_system_access_permission_context.h
@@ -107,12 +107,6 @@ class FileSystemAccessPermissionContext 
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) = 0;
 
   enum class AfterWriteCheckResult { kAllow, kBlock };
-  // Runs a recently finished write operation through checks such as malware
-  // or other security checks to determine if the write should be allowed.
-  virtual void PerformAfterWriteChecks(
-      std::unique_ptr<FileSystemAccessWriteItem> item,
-      GlobalFrameRoutingId frame_id,
-      base::OnceCallback<void(AfterWriteCheckResult)> callback) = 0;
 
   // Returns whether the give |origin| already allows read permission, or it is
   // possible to request one. This is used to block file dialogs from being
